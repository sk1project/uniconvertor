%%BeginResource: procset Linux-sK-Procset 1.0 2

% version 1.0 0 released with Sketch 0.5.0, 0.5.1 and 0.5.2
% version 1.0 1 released with Sketch 0.5.3
%   changes: rect procedure extended to allow rounded corners
% version 1.0 2 released as patch for 0.6.3 and with 0.6.4 and 0.7.4
%   changes: in skeps, redefine showpage after userdict begin
% version 1.0 3 released with sK1 v0.9
%   changes: CMYK colorspace support

/SketchDict 100 dict def
SketchDict begin

/bd { bind def } bind def
/x { exch } bd
/xd { exch def } bd

/PI 3.14159265358979323846264338327 def
% convert radians to grad
/radgrad { 180 mul PI div } bd

/skstartmatrix matrix currentmatrix def
/tmpmat matrix def
/ISOLatin1Encoding dup where
{ pop pop }
{  [/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /space /exclam /quotedbl /numbersign /dollar /percent /ampersand
/quoteright /parenleft /parenright /asterisk /plus /comma /minus /period
/slash /zero /one /two /three /four /five /six /seven /eight /nine /colon
/semicolon /less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J
/K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /quoteleft /a /b /c /d /e /f /g /h /i
/j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar /braceright
/asciitilde /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /dotlessi /grave /acute /circumflex /tilde /macron /breve
/dotaccent /dieresis /.notdef /ring /cedilla /.notdef /hungarumlaut /ogonek
/caron /space /exclamdown /cent /sterling /currency /yen /brokenbar /section
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen
/registered /macron /degree /plusminus /twosuperior /threesuperior /acute /mu
/paragraph /periodcentered /cedilla /onesuperior /ordmasculine /guillemotright
/onequarter /onehalf /threequarters /questiondown /Agrave /Aacute /Acircumflex
/Atilde /Adieresis /Aring /AE /Ccedilla /Egrave /Eacute /Ecircumflex
/Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth /Ntilde /Ograve
/Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash /Ugrave /Uacute
/Ucircumflex /Udieresis /Yacute /Thorn /germandbls /agrave /aacute
/acircumflex /atilde /adieresis /aring /ae /ccedilla /egrave /eacute
/ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis /eth /ntilde
/ograve /oacute /ocircumflex /otilde /odieresis /divide /oslash /ugrave
/uacute /ucircumflex /udieresis /yacute /thorn /ydieresis] def
}
ifelse

% define arct for level 1
/arct dup where
{pop pop}
{
	/arct {arcto pop pop pop pop} bd
}
ifelse

/size 0 def
/fontname 0 def
/newfont 0 def
% <fontname> <size> sf -
/sf {
	/size xd
	/fontname xd

	fontname findfont
	% reencode fonts if they use the standard encoding
	dup /Encoding get StandardEncoding eq
	{
		dup
		length dict /newfont xd
		{
			1 index
			/FID ne
			{ newfont 3 1 roll put }
			{ pop pop }
			ifelse
		} forall
	
		newfont /Encoding ISOLatin1Encoding put
		fontname newfont definefont
	}
	if

	size scalefont setfont
} bd

/pusht {matrix currentmatrix} bd

/popt {setmatrix} bd


/pushc {gsave} bd

/popc {grestore} bd

% <r> <g> <b>	 rgb -
/rgb {setrgbcolor} bd

% <c> <m> <y> <k>	 cmyk -
/cmyk {setcmykcolor} bd

% <linewidth> w -
/w { setlinewidth } bd

% <linejoin> j -
/j { setlinejoin } bd

% <linecap> J -
/J { setlinecap } bd

% [<dashes>] <phase> d -
/d { setdash } bd



/F { eofill } bd
/f { closepath F } bd
/S {
	pusht
	skstartmatrix setmatrix stroke 
	popt
} bd
/s { closepath S } bd

/m { moveto } bd
/l { lineto } bd
/c { curveto } bd

% [<matrix>]	txt [<oldmatrix>]
% <x> <y>	txt [<oldmatrix>]
/txt {
	/tmpmat tmpmat currentmatrix def
	dup type /arraytype eq {concat} {translate} ifelse
	0 0 m
	tmpmat
} bd

% <string> [<matrix>]	T -
% <string> <x> <y>	T -
/T {txt x show popt} bd

% <string> [<matrix>]   P -
% <string> <x> <y>      P -
/P {txt x true charpath popt} bd

% <string> [<matrix>]	TP -
% <string> <x> <y>	TP -
/TP {txt x dup show 0 0 m true charpath popt} bd

% <x> <y> <radius>	C -
/C {newpath 0 360 arc} bd

% <x1> <y1> <x2> <y2>  R -
/R {
	2 copy m
	x 2 index l
	x 2 index x l
	l
	closepath
} bd

% [<matrix>]			    ellipse -
% [<matrix>] <start> <end> <type>   ellipse - 
/ellipse { 
	dup type /arraytype eq
	{
		pusht x concat
		0 0 1.0 C 
		popt
	}	
	{
		pusht 5 1 roll
		4 -1 roll concat
		newpath
		dup 2 eq {
			% pie slice
			0 0 m 
		} if 
		% save arc type  
		3 1 roll
		% convert radians to degree
		radgrad x
		radgrad x
		% center 0 0 and radius 1
		0 0 1   5 -2 roll
		arc
		% close for pie slice and chord
		0 ne { closepath } if
		popt
	}
	ifelse
} bd

% [<matrix>] rect -
% [<matrix>] radius1 radius2 rect -
/radius1 0 def
/radius2 0 def
/factor 0 def
/rect {
	dup type /arraytype eq
	{
		% normal rectangle
		pusht x concat
		0 0 m  1 0 l  1 1 l  0 1 l  closepath
		popt
	}
	{
		% rectangle with round corners
		/radius2 xd
		/radius1 xd
		pusht x concat
		radius1 radius2 div  1  scale
		0 radius2 m
		0 1  radius2 1  radius2  arct
		radius2 radius1 div
		dup 1  1 index 0  radius2  arct
		0  0 0  radius2  arct
		0 0  0 1  radius2 arct
		closepath
		popt
	}
	ifelse
} bd


/buf 0 def
/width 0 def
/height 0 def
% <width> <height> [<matrix>] true skcimg -
% <width> <height> false	   skcimg -
/skcimg {
	% this needs the color extension of Level 1 or Level 2
	/tmpmat tmpmat currentmatrix def
	{ concat } if
	/height xd
	/width xd

	/buf width 3 mul string def
	width height scale
	width height 8
	[width	 0   0	 height neg	  0  height]
	{ currentfile buf readhexstring pop } bind
	false 3 colorimage
	tmpmat setmatrix
} bd

% <width> <height> [<matrix>] true skgimg -
% <width> <height> false	   skgimg -
/skgimg {

	/tmpmat tmpmat currentmatrix def
	{ concat } if
	/height xd
	/width xd

	/buf width string def
	width height scale
	width height 8
	[width	 0   0	 height neg	  0  height]
	{ currentfile buf readhexstring pop } bind
	image
	tmpmat setmatrix
} bd

% <llx> <lly> <w> <h>  rclip -
/rclip {
	4 2 roll m
	dup 0 x rlineto
	x 0 rlineto
	neg 0 x rlineto
	closepath
	clip
} bd
	

% <llx> <lly> <w> <h> [<matrix>]  skeps
/skeps {
	10 dict begin
		/sk_state save def
		concat
		3 index neg 3 index neg translate
		rclip
		0 setgray 0 setlinecap 1 setlinewidth 0 setlinejoin
		10 setmiterlimit [ ] 0 setdash
		newpath
		/sk_dict_count countdictstack def
		/sk_count count 1 sub def
		userdict begin
			/showpage { } def
			/languagelevel where
			{
				pop
				languagelevel 1 ne
				{
					false setstrokeadjust
					false setoverprint
				} if
			} if
} bd 

/skepsend {
	count sk_count sub { pop } repeat
	countdictstack sk_dict_count sub { end } repeat
	sk_state restore
	end
} bd

%
%   Gradient Patterns
%

/gradidx 0 def
% num	gradient <array>
/gradient { 
	3 mul array
	/gradidx 0 def
} bd

% array red green blue  $   array
/$ {
	3 index gradidx       5 -1 roll put 
	2 index gradidx 1 add 4 -1 roll put 
	1 index gradidx 2 add 3 -1 roll put 
	/gradidx gradidx 3 add def
} bd

% array ! array	    % repeat the last color specified
/! { 
	3 
	{
		dup dup gradidx dup 3 1 roll 3 sub get put
		/gradidx gradidx 1 add def
	}
	repeat
} bd


% array idx gradcolor  array red green blue
/gradcolor {
	3 mul dup 2 add 1 exch	% idx  1  idx+2
	{
		1 index exch	% array array i
		get		% array component
		exch		% component array
	}
	for
	4 1 roll
} bd
		
		
% array x0 y0 x1 y1 axial -
/x0 0 def /y0 0 def /x1 0 def /y1 0 def
/left 0 def /right 0 def /top 0 def /bottom 0 def
/numcolors 0 def

/axial	{
	/y1 xd /x1 xd /y0 xd /x0 xd
	dup length 3 idiv /numcolors xd
	pusht exch  % ctm array

	x0 x1 ne y0 y1 ne or
	{
		x0 y0 translate
		[x1 x0 sub  y1 y0 sub	dup neg    2 index    0	    0] concat
		
		clippath flattenpath pathbbox
		/top xd /right xd /bottom xd /left xd
		newpath

		0 gradcolor rgb clippath f

		0 1 numcolors 1 sub
		{
			dup numcolors div
			3 1 roll
			gradcolor rgb
			exch
			bottom right top R f
		}
		for
	}
	if 
	% pop the colors array
	pop

	% restore CTM
	popt
} bd

% array x y r0 r1 radial -
%reuse: /x0 0 def /y0 0 def 
%reuse: /left 0 def /right 0 def /top 0 def /bottom 0 def
%reuse: /numcolors 0 def
/r0 0 def /r1 0 def /dr 0 def
/radial	{
	/r1 xd /r0 xd /y0 xd /x0 xd
	/dr r1 r0 sub def
	dup length 3 idiv /numcolors xd
	pusht exch  % ctm array

	r0 r1 ne
	{

		x0 y0 translate
		
		clippath flattenpath pathbbox
		/top xd /right xd /bottom xd /left xd
		newpath

		dr 0 gt {numcolors 1 sub}{0} ifelse gradcolor rgb
		clippath f

		dr 0 gt {numcolors 1 sub -1 0} { 0 1 numcolors 1 sub} ifelse
		{
			dup numcolors div dr mul r0 add
			3 1 roll
			gradcolor rgb
			exch
			0 0 3 -1 roll C f
		}
		for
	}
	if 
	% pop the colors array
	pop

	% restore CTM
	popt
} bd

% a b  max  <maximum of a and b>
/max {
	2 copy lt {exch} if pop
} bd



% array x y angle   conical -
%reuse: /x0 0 def /y0 0 def 
%reuse: /numcolors 0 def
/conical {
	pusht 5 1 roll
	3 1 roll /y0 xd /x0 xd
	x0 y0 translate
	radgrad rotate
	
	dup length 3 idiv /numcolors xd

	clippath flattenpath pathbbox newpath
	4 { abs 4 1 roll} repeat
	3 { max } repeat
	2 mul
	dup scale

	% now we can use radius 1

	0 gradcolor rgb
	0 0 1 0 360 arc f
	1 1 numcolors 1 sub
	{
		dup numcolors div 180 mul
		3 1 roll
		gradcolor rgb
		exch
		0 0 moveto
		0 0 1  4 -1 roll  dup neg  arc
		closepath f
	}
	for

	% pop the colors array
	pop

	% restore CTM
	popt
} bd

% width height ncomp trafo  tileimage -
% followed by hexdata
%reuse: width height
/XStep 0 def /YStep 0 def /imagedata 0 def /components 0 def
/tileimage2 {
	exch 4 2 roll
	/height xd
	/width xd
	%<<
	mark
	/components 2 index
	/PatternType 1
	/PaintType 1
	/TilingType 1
	/BBox [0 0 width height]
	/XStep width
	/YStep height
	/PaintProc {
		begin
			% XStep and YStep must contain the image size
			XStep YStep 8
			% identity matrix, since the mapping from image
			% space to user space is already contained in
			% the trafo passed to makepattern
			matrix
			imagedata
			false
			components
			colorimage
		end
	}
	%>>
	counttomark 2 div cvi dup dict begin
		{ def } repeat
	pop currentdict end
	% read the image and put into pattern dict
	% stack now: trafo ncomp patterndict
	dup
	/imagedata
	4 -1 roll
	width height mul mul string
	currentfile exch readhexstring pop
	put
	% stack now: trafo patterndict
	exch
	makepattern
	setpattern
	clippath
	eofill
} bd


/tileimage1 {
	concat
	/components xd
	/height xd
	/width xd
	/imagedata
	currentfile
	width height mul components mul string
	readhexstring pop
	def

	clippath flattenpath pathbbox
	/top xd /right xd /bottom xd /left xd
	left width div floor width mul
	bottom height div floor height mul
	translate
	top bottom sub height div ceiling cvi
	{
		gsave
		right left sub width div ceiling cvi
		{
			width height 8 matrix
			components 1 eq
			{
				{ imagedata }
				image
			}
			{
				imagedata
				false components
				colorimage
			}
			ifelse
			width 0 translate
		}
		repeat
		grestore
		0 height translate
	}
	repeat
} bd

/makepattern where
{
	pop
	/tileimage /tileimage2 load def
}
{
	/tileimage /tileimage1 load def
}
ifelse


% end SketchDict
end

%%EndResource
